# 软件

## 软件工程概述

- 软件特性
    > `软件` = `程序` + `数据` + `文档`
    > `程序`：计算机可以接受的一系列指令，运行时可以提供所要
    > 求的功能和性能。
    > `数据`：使得程序能够适当地操作信息的数据结构。
    > `文档`：描述程序的研制过程、方法和使用的图文资料  

- 软件的本质特性
    > 软件具有**复杂性、一致性、可变性和不可见性**等固有的内在特性，这是造成软件开发困难的根本原因  

---

- 软件危机
    > **软件危机**是指计算机软件的开发和维护过程中所遇到的一系列严重问题.

---

- 软件工程的基本目标
    > 软件工程的**基本目标**是**经济**的开发出**高质量**的软件.

---

- 软件开发基本策略
   > 1. 软件复用
   > 1. 分而治之
   > 1. 逐步演进
   > 1. 优化折中

---

- 软件工程七大基本原理
    > 1. 用**分阶段**的生命周期计划严格管理
    > 1. 坚持进行**阶段评审**
    > 1. 实行严格的**产品控制**
    > 1. 采用**现代**程序设计**技术**
    > 1. 结果应能**清楚**地审查
    > 1. 开发小组的人员应**少而精**
    > 1. 不断改进软件工程实践的**必要性**

---

## 软件过程

>  软件过程的基本活动是**分析**、**设计**、**实现**、**测试**、**演化**


- **软件过程模型**
    - 几大模型

    >  - **瀑布模型**  
    @import "2.3-model1.png"
    @import "2.3-model2.png"  

    >  - **原型化模型**
    @import "2.3-model3.png"

    > - **迭代式开发**
      - 更快速地发布产品  
      - 追求产品创新
      - 需求不确定性高
      - 需要快速响应用户的变化
      - 关注用户行为
      @import "2.3-model4.png"  

    > - **演化原型模型**
    @import "2.3-model5.png"  

    > - **统一过程模型**
    @import "2.3-model6.png"

---

- **敏捷开发**
    - 基本原则
    @import "2.3-model7.png"

    - 敏捷宣言
    @import "2.3-model8.png"

## 需求获取
- **需求定义**
    > **需求**是对外可见的系统特征。
    **需求管理** 有三项任务：
    • 学习 —— 需求获取
    • 剪枝—— 需求优选
    • 文档化—— 撰写需求规格说明书 

    >**需求**，是人们要解决的某个问题或达到某种目的的需要。是系统或其组成
部分为满足某种**书面规定**（合同，标准，规范等）所要具备的能力。需求将作
为系统**开发、测试、验收、提交的正式文档依据**
    >每一个“**人造物**”都是一个**内部环境**与**外部环境**的
“**接口**”。这里内部环境指人造物本身的设计组成。外
部环境指人造物的周遭及其作用环境。对这个接口的描
述既是需求

---

- **需求分类**    
    - 按软件需求修饰的对象不同
        - 软件产品需求
            >- 功能性需求指代软件产品的功能特性
            >- 非功能性需求是软件产品的质量属性 
        - 软件过程需求
    - 按软件需求面向对象的不同以及抽象层次和详细程度的不同
        > - 业务需求
        > - 系统需求
        > - 用户需求
        > - 软件设计规约
    - 系统需求明确待开发系统的特性
        > - 功能性需求
        > - 非功能性需求

---

## 用例建模

- UML
    > **用例图**(use case diagram )：由参与者、用例以及它们之间的关系构成的，用于描述系统功能的动态视图

    > - 关联干系人需求以及软件需求
    > - 确认与系统交互的人或对象（参与者）
    > - 定义系统的边界
    > - 捕捉和传达系统的理想行为（用例）
    > - 验证或确认需求
    > - 规划工具 

    > - 组成
    @import "4.4-usecase2.png"
    @import "4.4-usecase3.png"
    @import "4.4-usecase4.png"
    @import "4.4-usecase5.png"
    @import "4.4-usecase6.png"
    @import "4.4-usecase7.png"
    @import "4.4-usecase8.png"



- **用例图建模** 

    - 过程
        > 1. 找到所有的参与者和用例
            - 识别出参与者并做简单的描述
            - 识别出用例并做简单的介绍
        > 2. 编写用例
            - 给用例事件流程划分重要等级
            - 按照重要程度排序详细描述事件流程
    - 步骤
        > 1. 找出系统外部的参与者和外部系统，确定系统的边界和范围；
        > 2. 确定每一个参与者所期望的系统行为；
        > 3. 把这些系统行为命名为Use Case；
        > 4. 绘制Use Case图；
        > 5. 编制每一个Use Case的脚本；
        > 6. 区分主事件流和异常情况的事件流，可以把表示异常情况的事件流作为单独的Use Case处理；
        > 7. 使用泛化、包含、扩展等关系处理系统行为的公共或变更部分；
        > 8. 细化Use Case图，解决Use Case间的重复与冲突问题。
    - 关系
        > - 包含
        @import "4.4-usecase9.png"
        > - 拓展
        @import "4.4-usecase10.png"
        > - 泛化
          描述参与者于参与者以及用例和用例之间的关系.
          意味着一个参与者可以完成另一个参与者**同样**的任务,也可以补充额外的任务.
          用例之间的泛化关系意味着一个用例是另一个用例的**特殊版本**
          UML中用一个带连线的三角形来表示泛化关系.

        > - 包含关系与扩展关系的联系与区别
        > **联系**
        从现有的用例中抽取出公共的那部分信息，作为一个单独的用例，通过不同的方法来重用。
        > **区别**
             `包含关系`：在执行基本用例时，包含用例一定会执行。
             `扩展关系`：在执行基本用例时， 扩展用例可以执行，也可以不执行。
    - 用例规约
        > 1. 找出用例的执行者和目标
        > 2. 撰写用例概述和主成功场景
        > 3. 考虑操作失败的场景
        > 4. 列出所有可替换场景

---

## 软件体系结构
- 体系结构风格
    - 三层c/s架构
        > **客户机／服务器体系结构** 是一种分布式系统模型，作为服务器的子系统为其他客户机的子系统提供服务，作为客户机的子系统负责与用户的交互。
        @import "5.3.1.png"

    - 管道/过滤器风格
        > 把系统任务分成若干连续的处理步骤，这些步骤由通过系统的数据流连接，一个步骤的输出是下一个步骤的输入
        @import "5.3.2.png"

    - 数据仓库风格
        > **仓库体系结构**（Repository Architecture）是一种以数据为中心的体系结构，适合于数据由一个模块产生而由其他模块使用的情形
        @import "5.3.3.png"

        > 常见的体系结构
        @import "5.3.4.png"
        @import "5.3.5.png"

---

- 软件体系结构风格的选择
    > 绝大多数实际运行的系统都是几种**体系结构的复合**

    根据实际的开发经验，我们总结一些体系结构的选择原则：
    > - **层次化**的思想在任何系统中都可能得到应用
    > - 如果问题可分解为连续的几个阶段，那么考虑使用顺序**批处理**风格或**管道---过滤器**风格
    > - 如果核心问题是应用程序中数据的理解、管理与表示，那么考虑使用**仓库**或者**抽象数据类型（ADT）/OO**风格
    > - 如果数据是持久存在的，则使用**仓库**结构
    > - 如果任务之间的控制流可预先设定、无须配置，那么考虑使用**主程序---子过程**风格、**OO**风格
    > - 如果任务需要高度的灵活性与可配置性、松散耦合性或者任务是被动性的，那么考虑使用**事件系统**或**C/S**风格
    > - 如果设计了某种计算，但没有机器可以支持它运行，那么考虑使用**虚拟机/解释器**体系结构
    > - 如果要实现一些经常发生变化的业务逻辑，考虑使用**基于规则的系统**

- 体系结构风格和软件框架
    **体系结构风格**：用于描述某一特定应用领域中系统组织的惯用模式，反映了领域中众多系统所共有的结构和语义特性。
    **软件框架**：软件框架是由开发人员定制的应用系统的骨架，是整个或部分系统的可重用设计，由一组抽象构件和构件实例间的交互方式组成。

    - 体系结构风格和软件框架的关系
    > **体系结构**的呈现形式是一个设计规约，而**框架**则是“半成品”的软件；
    > **体系结构**的目的是指导软件系统的开发，而**框架**的目的是设计复用

---

## 面向对象分析与设计

- 类的定义
    - 类图的定义
        > **类图**使用出现在系统中的不同类来描述系统的**静态结构**,它用来描述不同的类以及它们之间的关系.与数据模型不同的是,它不仅显示了信息的结构,也包含了系统的行为.

        > - 类
        @import "4.3.1.png"

        > - 对象
        @import "4.3.2.png"

        > - 类属性
        @import "4.3.3.png"

    - 类关系
        > 对象并非遗世独立，对象间存在千丝万缕的联系
        > UML中，关注以下几种类型的关系:
        > - 关联关系（Association）
        >   - 聚合与组合关系
            @import "4.3.4.png"
            @import "4.3.5.png"
            @import "4.3.6.png"
            @import "4.3.7.png"
            @import "4.3.8.png"
        >   - **聚合**: 表达的是一个整体对象和它的**成员对象**之间的关系.聚合关系中,代表部分事物的对象是可以属于多个聚合对象的.UML中,用空心菱形的直线表示.
        >   - **组合**: 是聚合的一个**特例**,它所代表的是一个整体对象和**部分组成**之间的关系.两者之间的所属关系更强,当整体对象**不存在**时,部分类的对象也**不存在**.

        > - 泛化关系（Generalization）
        >   **泛化**（Generalization)关系也就是**继承关系**,用于描述父类与子类的关系,父类又称作**基类**或超类,子类又称作**派生类**.
            @import "4.3.9.png"
            @import "4.3.10.png"

        > - 依赖关系（Dependency）
        >   **依赖关系**是一种**使用**关系,特定事物的改变有可能会影响到使用该事物的**其他事物**,在需要表示一个事物使用另一个事物时使用依赖关系.
        >  在UML中,用**虚箭线**表示.

        > - 实现关系（Realization）
        >   **实现关系**中,类实现了接口,类中的操作实现了接口中所声明的操作.

    - 关联类
        > 有时要为关联相关信息的存储定义一个专门的类，称为“**关联类**”
        >  - 保存与关联关系本身相关的信息，这些信息不属于关联所连接的两端的类 
            @import "4.3.11.png"

---

- CRC分拣法
    > CRC卡片分析法是从文档中提取**类定义**的最常用方法之一.
    @import "4.3.3.1.png"

    > CRC实际上就是一组表示类的**索引卡片**,每张卡片的三个部分描述了**类名**,**类的职责**,**类的协作者**.

    > **CRC建模**的大志包括以下5个步骤(p119~121):
    > - 标识潜在的对象类.
    > - 筛选对象类,确定最终对象类.
    > - 标识职责
    > - 标识协作者
    > - 复审CRC卡片

    @import "4.3.3.2.png"
    @import "4.3.3.3.png"
    @import "4.3.3.4.png"
---
- OO的设计原则
    - SOLID各个原则及其含义
    > - **单一职责原则**(Single Responsibility Principle)
        @import "4.7.1.png"

    > **开闭原则**（Open/Closed Principle，OCP）
        @import "4.7.2.png"

    > **里式替换原则**(Liskov Substitution Principle, LSP)
        @import "4.7.3.png"
        @import "4.7.4.png"

    > **接口隔离原则**(Interface Segregation Principle, ISP)
        @import "4.7.5.png"
    
    > **依赖倒转原则**(Dependency Inversion Principle, DIP)
        @import "4.7.6.png"

- OO设计时需要注意的一些问题
    @import "4.7.7.png"

---

## 行为建模

- 顺序图建模
    > **顺序图**按时间的**次序**,表示对象之间的消息,指出有哪些对象参与了交互以及它们之间消息传递的序列.

    > **顺序图**的建模元素主要包括**对象**,**生命线**,**控制焦点**和**消息**

    - 对象及其生命线
    > 主要刻画对象是以何种角色参与到交互场景中来的.
        @import "4.5.1.1.png"
        
    >  - 对象的命名规范
    >    - 完整命名 __<对象名>:<类名>__
    >    - 匿名对象    __:<类名>__
    >    - 未知类   __<对象名>:__
    - 控制焦点/激活期
    > 它表示对象进行操作的时间片段,表明对象处在活动状态.
        @import "4.5.1.2.png"
    
    - 消息
    > **消息**（Message）用于描述对象间的交互操作和值传递过程
        @import "4.5.1.3.png"
    
    > - 消息的类型:
    >   - **同步消息**
    >   - **异步消息**
    >   - **返回消息**
    >   - **自关联的消息**
    >   - **超时等待**
    >   - **阻塞**
    >   其中,最常用的是**同步**和**异步**消息.


- 顺序图绘制
    @import "4.5.2.1.png"

- 顺序图与用例的关系
    > - 顺序图表达用例的**单个场景**实例的行为
    > - 顺序图表达对象间如何**协作**完成用例所描述的功能
    > - 顺序图可用于开发周期的不同阶段，服务于不同目的，描述不同粒度的行为
    >   - 用于表示为完成用例而在**系统边界**输入输出的数据以及消息
    >   - 用于表示**系统内部**对象间的消息传递

---

- 状态建模
    - 状态
    @import "4.6.1.png"

    - 对象,状态空间
    @import "4.6.2.png"
    @import "4.6.3.png"

    - 状态变迁
    @import "4.6.4.png"
    > 对于给定的状态，最终只能产生**一个迁移**，因此从相同的源状态、触发事件相同的几个迁移之间的条件应该是**互斥**的
    
    > - **事件**(Events)的意义在于系统需要了解正在发生什么
    >   - 状态图中，事件仅需和系统或当前建模的对象相关
    >   - 从系统角度出发，事件必须建模成一个瞬间可完成的动作
    >   - 在OOD中通过传递消息的方式实现事件
    > - 在UML中，有四种类型的**事件**:
    >   - **变更事件**(Changeevents)：当给定条件成立时就会发生变更事件
        @import "4.6.6.png"
    >   - **调用事件**(Callevents)：当给定对象的操作被调用执行时会发生调用事件
        @import "4.6.5.png"
    >   - **时间事件**(Elapsed-timeevents)：表明时间段过去，或某个特殊时间点的触发
        @import "4.6.7.png"
    >   - **信号事件**(Signalevents)：当给定对象收到某实时信号
    - UML状态图中的动作（Action）
        @import "4.6.8.png"

    - UML状态图中的状态（State）
        @import "4.6.9.png"
    @import "4.6.10.png"

---

## 编写高质量的代码

- 编码规范
    - 注释
    @import "6.1.1.png"
    @import "6.1.2.png"

    - 命名
    @import "6.1.3.png"
    @import "6.1.4.png"

    - 语句
    @import "6.1.5.png"

- 代码优化
    @import "6.2.1.png"
    @import "6.2.2.png"
    @import "6.2.3.png"

---

## 软件测试

- 软件测试
    @import "7.2.1.png"
    @import "7.2.2.png"
    @import "7.2.3.png"

---

- 测试用例的设计
    @import "7.2.4.png"
    @import "7.2.5.png"
    @import "7.2.6.png"

---

- 软件测试类型
    @import "7.3.1.png"

    > - **单元测试**（Unit Testing）是对软件基本组成单元进行的测试，其测试对象是软件设计的最小单位（模块或者类）。
    > - **集成测试**（Integration Testing）是在单元测试的基础上，将所有模块按照总体设计的要求组装成为子系统或系统进行的测试
    >   - **一次性集成方式**：分别测试每个单元，再一次性将所有单元组装在一起进行测试。
    >   - **渐增式集成方式**：先对某几个单元进行测试，然后将这些单元逐步组装成较大的系统，在组装过程中边连接边测试。
    > - **功能测试**（Functional Testing）是在已知产品所应具有的功能基础上，从**用户角度**来进行功能验证，以确认**每个功能**是否都能正常使用。
    > - **性能测试**（Performance Testing）是在实际或模拟实际的运行环境下，针对非功能特性所进行的测试，包括压力测试、容量测试、安全测试和可靠性测试等。
    > - **验收测试**（Acceptance Testing）是在软件产品完成了系统测试之后、产品发布之前进行的软件测试活动，其目的是验证软件的功能和性能是否能够满足用户所期望的要求
    > - **安装测试**是系统验收之后，需要在目标环境中进行安装，其目的是保证应用程序能够被**成功地安装**。
    > - **黑盒测试**：将测试对象看做一个黑盒子，完全不考虑程序内部的逻辑结构和内部特性，只是依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明
    > - **白盒测试**：把测试对象看做一个透明的盒子，允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。
    > - **静态测试**：通过人工分析或程序正确性证明的方式来确认程序正确性。
    > - **动态测试**：通过动态分析和程序测试等方式检查程序执行状态，以确认是否有问题。
    > - **手工测试**：测试人员根据测试大纲中所描述的测试步骤和方法，手工地输入测试数据并记录测试结果。
    > - **自动化测试**：相对于手工测试而言，主要是通过所开发的软件测试工具或脚本等手段，按照测试工程师的预定计划对软件产品进行的自动测试。

---

- 黑盒测试
    @import "7.4.1.png"
    - 等价类划分
        @import "7.4.2.png"
        @import "7.4.3.png"
        @import "7.4.4.png"
    
    - 边界值分析
        @import "7.4.5.png"
        @import "7.4.6.png"

---

- 白盒测试
    > **白盒测试**是将测试对象看做一个透明的盒子，允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。

    - 单元测试质量
    > - **测试通过率**是指在测试过程中执行通过的测试用例所占比例，单元测试通常要求测试用例通过率达到100%
    > - **测试覆盖率**是用来度量测试完整性的一个手段，通过覆盖率数据，可以了解测试是否充分以及弱点在哪里。代码覆盖率是单元测试的一个衡量标准，但也不能一味地追求覆盖率

    - 测试覆盖
        @import "7.5.1.png"

    - 代码覆盖
    > **代码覆盖率**描述的是代码被测试的比例和程度，通过代码覆盖率可以得知哪些代码没有被覆盖，从而进一步补足测试用例
        @import "7.5.2.png"
    
    @import "7.5.3.png"
    @import "7.5.5.png"
    @import "7.5.4.png"
    @import "7.5.6.png"
    @import "7.5.7.png"
    @import "7.5.8.png"

    > - 如何看待测试覆盖率
    >   -  覆盖率数据只能代表测试过哪些代码，不能代表是否测试好这些代码.
    >   - 较低的测试覆盖率能说明所做的测试还不够，但反之不成立
    >   - 路径覆盖 > 判定覆盖 > 语句覆盖
    >   - 测试人员不能盲目追求代码覆盖率，而应该想办法设计更好的测试用例
    >   - 测试覆盖率应达到多少需要考虑软件整体的覆盖率情况以及测试成本