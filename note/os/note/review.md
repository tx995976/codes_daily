
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [操作系统引论](#操作系统引论)
  - [操作系统的发展过程](#操作系统的发展过程)
  - [操作系统的基本特征](#操作系统的基本特征)
  - [操作系统的运行环境](#操作系统的运行环境)
  - [操作系统的主要功能](#操作系统的主要功能)
  - [系统调用](#系统调用)
- [进程的描述与控制](#进程的描述与控制)
  - [前趋图和程序执行](#前趋图和程序执行)
  - [进程的描述](#进程的描述)
  - [进程控制](#进程控制)
  - [进程通信](#进程通信)
- [处理机调度与死锁](#处理机调度与死锁)
  - [处理机调度概述](#处理机调度概述)
  - [调度算法](#调度算法)
  - [实时调度](#实时调度)
  - [死锁概述](#死锁概述)
  - [预防死锁](#预防死锁)
  - [死锁避免](#死锁避免)

<!-- /code_chunk_output -->

# 操作系统引论

---
## 操作系统的发展过程
---
- 无操作系统的计算机系统
    - 人工操作方式
    > 缺点：
    > - 用户独占全机
    > - CPU等待人工操作

    - 脱机I/O方式
    > 优点：
    > - 减少了CPU的空闲时间
    > - 提高了I/O速度
---
- 单道批处理系统
    @import "1.1.png"

- 多道批处理系统
    @import "1.2.png"

- 分时系统
    @import "1.3.png"
    > 分时系统的特征
    > - **多路性** 允许将多台终端同时连接到一台主机，并分时使用
    > - **独立性** 感觉用户独占主机
    > - **及时性** 用户的请求能在很短时间内获得响应
    > - **交互性** 用户可通过终端与系统进行广泛的人机对话

- 实时系统
    > 实时系统：系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。
    > 最主要的特征：**实时性**
    @import "1.4.png"

---

## 操作系统的基本特征

@import "1.5.png"

> - 并发(Concurrence)
>   正是系统中的程序能并发执行这一特征，才使得OS能有效地提高系统中的资源利用率，增加系统的吞吐量。
>  1. 并行与并发
>   并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔内发生。 

> - 共享(Sharing)
>   一般情况下的共享与操作系统环境下的共享其含义并不完全相同。
> 1. 互斥共享方式
>   系统中的某些资源，如打印机、磁带机等，虽然可以提供给多个进程(线程)使用，但应规定在一段时间内，只允许一个进程访问该资源。为此，在系统中应建立一种机制，以保证多个进程对这类资源的互斥访问。
> 2. 同时访问方式系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下是宏观意义上的，而在微观上，这些进程对该资源的访问是交替进行的。典型的可供多个进程“同时”访问的资源是磁盘设备。一些用重入码编写的文件也可以被“同时”共享，即允许若干个用户同时访问该文件。

> - 虚拟(Virtual)
> 1. 时分复用技术
> (1) 虚拟处理机技术。虽然系统中只有一台处理机，但通过时分复用技术能实现（宏观上）**同时**为多个用户服务，使每个终端用户都认为有一个处理机在专门为他服务
> (2) 虚拟设备技术。利用时分复用技术，将一台物理上的1/0设备虚拟为多台逻辑上的1/0设备，并允许每个用户占用一台逻辑上的1/0设备。这样便可使原来仅允许在一段时间内由一个用户访问的设备（即临界资源），变为允许多个用户“同时＂访问的共享设备，即其在**宏观**上能“同时”为多个用户服务。
> 2. 空分复用技术20世纪初，电信业中就已使用频分复用技术来提高信道的利用率。它是指将一个频率范围比较宽的信道划分成多个频率范围较窄的信道(称为频带)，其中的任何一个频带都仅供一对用户通话。早期的频分复用技术只能将一条物理信道划分为几条到几十条话路，后来又很快发展到成千上万条话路，每条话路供一对用户通话。再后来在计算机中也把空分复用技术用于对存储空间的管理，用以提高存储空间的利用率。

> - 异步(Asynchronis)
> 在多道程序环境下，系统允许多个进程并发执行。在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。当正在执行的进程提出某种资源要求时，如打印请求，而此时打印机正在为其它进程打印，由于打印机属于临界资源，因此正在执行的进程必须等待，并释放出处理机，直到打印机空闲，并再次获得处理机时，该进程方能继续执行。可见，由于资源等因素的限制，使进程的执行通常都不可能“一气呵成”，而是以“停停走走”的方式运行。

---

## 操作系统的运行环境

- 冯诺依曼架构

- 硬件支持
@import "1.6.png"

- 操作系统内核
@import "1.7.png"

- 处理机的双重工作模式
@import "1.8.png"

---
> - 特权指令：在内核态下运行的指令
>   - 不仅能访问用户空间，还能访问系统空间。
>   - 如启动外部设备、设置系统时钟、管中断、切换执行状态、I/O指令。
> - 非特权指令：在用户态下运行的指令
>   -  应用程序所使用的都是非特权指令。
>   -  防止应用程序的运行异常对系统造成破坏。
>   -  仅能访问用户空间。
---
@import "1.9.png"

---

- 中断与异常
@import "1.10.png"
@import "1.11.png"

> - 中断和异常处理必做事项
>   - 进入中断或异常时
>       - 需保存处理器状态，方便之后恢复执行
>       - 需准备好在高特权级下进行执行的环境
>       - 需选择合适的异常处理器代码进行执行
>       - 需保证用户态和内核态之间的隔离
>   - 处理时
>       - 需获得关于异常的信息，如系统调用参数、错误原因等
>   - 返回时
>       - 需恢复处理器状态，返回低特权级，继续正常执行流

---

## 操作系统的主要功能

- 处理机管理功能
@import "1.12.png"

---

- 存储器管理功能
@import "1.13.png"

---

- 设备管理功能
@import "1.14.png"

---

- 文件管理功能
@import "1.15.png"

---

- 接口管理功能
@import "1.16.png"

---

- 现代操作系统的新功能
@import "1.17.png"

---

## 系统调用

- 系统调用的基本概念
> - 系统调用目的
>   - 使应用程序可以通过它间接调用OS内核中的相关过程，取得相应的服务。
> - 系统调用**概念**
>   - 应用程序请求OS内核完成某功能时的一种过程调用；
>   - 用户与内核的接口。
> - 与一般过程调用的区别:
>   -  运行在不同的系统状态 内核态或用户态
>   -  状态的转换
>   -  返回问题
>   -  嵌套调用

@import "1.18.png"

- 系统调用的类型
@import "1.19.png"

---

# 进程的描述与控制

---

## 前趋图和程序执行

- 前趋图
@import "2.1.png"

---

- 程序顺序执行
> - 一个较大的程序通常都由若干个程序段组成
>   程序在执行时，必须按照某种先后次序逐个执行，仅当前一操作执行完后，才能执行后继操作

- 程序并发执行
@import "2.2.png"

> - 程序并发执行的特征
> - 间断性
>   - 并发程序之间相互制约。
>   - 执行——暂停执行——执行。
> - 失去封闭性
>   - 多个程序共享全机资源。
>   - 执行状态受外界因素影响。
> - 不可再现性
>   - 程序经过多次执行后，虽然其执行时的环境和初始条件都相同，但得到的结果却各不相同。例：两个循环程序共享一个变量

---

## 进程的描述

- 进程的定义和特征
> - 几种典型定义
>   - 进程是程序的一次执行。
>   - 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
>   - 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。

> - 进程定义:
>   - 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

> - 进程控制块(process control block, PCB) 
>   - 专门的数据结构，与进程一一对应。

> - 进程的特征:
    @import "2.3.png"

---

- 进程的基本状态与转换

@import "2.4.png"
@import "2.5.png"
@import "2.6.png"

---

- 挂起操作和进程状态的转换

> 1. 挂起操作的引入
> - 引入挂起操作的原因，是基于系统和用户的如下需要：
>   - 终端用户的需要。
>   - 父进程请求。
>   - 负荷调节的需要。
>   - 操作系统的需要。

@import "2.7.png"

---

- 操作系统中用于管理控制的数据结构 **进程控制块(PCB)**
@import "2.8.png"

> PCB的**作用**：
> -  **作为独立运行基本单位的标志；**
> -  **能实现间断性运行方式；**
> -  **提供进程管理所需要的信息；**
> -  **提供进程调度所需要的信息；**
> -  **实现与其他进程的同步与通信。**

> - PCB的**信息**
    @import "2.9.png"
    @import "2.10.png"
    @import "2.11.png"
    @import "2.12.png"

> - PCB的组织方式
    @import "2.13.png"
    @import "2.14.png"
    @import "2.15.png"

---

## 进程控制

---

- [ ] 进程创建
    @import "2.16.png"
    @import "2.17.png"

---

- [ ] 进程终止
    @import "2.18.png"

---

- [ ] 进程的阻塞与唤醒
    @import "2.19.png"

---

- [ ] 进程的挂起与激活
    @import "2.20.png"

---

## 进程通信

> 进程通信是指进程之间的信息交换
    @import "2.21.png"
    @import "2.22.png"

---

- 进程通信的类型
    @import "2.23.png"
    @import "2.24.png"
    @import "2.25.png"

---

- 消息传递通信的实现方式
    @import "2.26.png"
    @import "2.27.png"

---

- Linux进程通信方式

---
---

# 处理机调度与死锁

---

## 处理机调度概述

- 处理机调度层次

> - **高级调度**
>   调度对象：作业
>   根据某种算法，决定将外存上处于后备队列中的作业调入内存，并为它们创建进程和分配必要的资源。然后，将新创建的进程排在就绪队列上等待调度。
>   - 主要用于多道批处理系统中

> - **中级调度**
>   内存调度，将暂不运行的进程，调至外存等待
>   将处于外存上的急需运行的进程，调入内存运行

> - **低级调度**
>   调度对象：进程
>   根据某种调度算法，决定就绪队列中的哪个进程应获得处理机
>   应用在于多道批处理、分时和实时OS

---

- 作业和作业调度
    @import "2.28.png"

---

- 进程调度
    @import "2.29.png"
    @import "2.30.png"

---

- 处理机调度算法的目标
    @import "2.31.png"
- [ ] (带权)周转时间

    @import "2.32.png"
    @import "2.33.png"

> - 评价指标
> - **响应时间**：
>   - 从用户通过键盘提交请求开始，直到系统首次显示出处理结果为止的一段时间
> - **等待时间（进程调度）**：
>   - 进程在就绪队列中等待调度的所有时间之和。

---

## 调度算法

- 先来先服务调度算法(FCFS)
    @import "2.34.png"

---

- 短作业优先（SJF）调度算法
    @import "2.35.png"
    @import "2.36.png"

---

- 优先级调度算法PR
    @import "2.37.png"
    @import "2.38.png"
    @import "2.39.png"
    @import "2.40.png"
    @import "2.41.png"

---

- 时间片轮转(RR)调度算法
    @import "2.42.png"
    @import "2.43.png"

---

## 实时调度

> - 实时调度是针对实时任务的调度
> - 实时任务，都联系着一个截止时间
>   - 硬实时**HRT**任务  
>   - 软实时**SRT**任务  
> - 实时调度应具备一定的条件

---

- 实现实时调度的基本条件
    @import "3.1.png"
    @import "3.2.png"
    @import "3.3.png"

---

- 实时调度算法分类
    @import "3.4.png"
    @import "3.5.png"

---

- 最早截止时间优先(EDF)调度算法
    @import "3.6.png"
    @import "3.7.png"

---

## 死锁概述

> **死锁**（Deadlock）：指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，这些进程都将永远不能再向前推进。

---

- 资源问题
    @import "3.8.png"
    @import "3.9.png"

---

- 死锁原因
    @import "3.10.png"
    @import "3.11.png"
    @import "3.12.png"
    @import "3.13.png"

---

- 死锁定义,必要条件,处理方法
> **死锁**：一组等待的进程，其中每一个进程都持有资源，并且等待着由这个组中其他进程所持有的资源

---

@import "3.14.png"

---

@import "3.15.png"
@import "3.16.png"

---

## 预防死锁

---
@import "3.17.png"
@import "3.18.png"

---

## 死锁避免
> - 设一个简单而有效的模型，要求每一个进程声明它所需要的资源的最大数。
> - **死锁避免算法**动态检查资源分配状态以确保不会出现循环等待的情况。
> - 资源分配状态定义为可用的与已分配的资源数，和进程所需的最大资源量。

---

- 安全状态
@import "3.19.png"
@import "3.20.png"

---

@import "3.21.png"




